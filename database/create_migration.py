#!/usr/bin/env python3
"""
Utility script for creating new Alembic migrations for the LMS system.

This script simplifies the process of creating new Alembic migrations 
by providing a guided interface and common templates.

Usage:
    python create_migration.py
    python create_migration.py --message "Add user roles table"
    python create_migration.py --template table
"""

import os
import sys
import argparse
import subprocess
from pathlib import Path
import logging

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Get the directory of this script
SCRIPT_DIR = Path(__file__).resolve().parent
# Get the root directory of the project
ROOT_DIR = SCRIPT_DIR.parent
# Alembic directory
ALEMBIC_DIR = ROOT_DIR / "backend" / "alembic"

# Templates for different types of migrations
TEMPLATES = {
    "table": """
\"\"\"
{message}

Revision ID: {revision}
Revises: {down_revision}
Create Date: {create_date}
\"\"\"

from alembic import op
import sqlalchemy as sa
{imports}

# revision identifiers, used by Alembic
revision = '{revision}'
down_revision = '{down_revision}'
branch_labels = None
depends_on = None


def upgrade():
    # Create the new table
    op.create_table(
        '{table_name}',
        sa.Column('id', sa.Integer(), nullable=False),
        # Add your columns here
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    
    # Add indices
    op.create_index(op.f('ix_{table_name}_name'), '{table_name}', ['name'], unique=True)


def downgrade():
    # Drop indices
    op.drop_index(op.f('ix_{table_name}_name'), table_name='{table_name}')
    
    # Drop the table
    op.drop_table('{table_name}')
""",
    "column": """
\"\"\"
{message}

Revision ID: {revision}
Revises: {down_revision}
Create Date: {create_date}
\"\"\"

from alembic import op
import sqlalchemy as sa
{imports}

# revision identifiers, used by Alembic
revision = '{revision}'
down_revision = '{down_revision}'
branch_labels = None
depends_on = None


def upgrade():
    # Add new column
    op.add_column('{table_name}', sa.Column('{column_name}', sa.{column_type}(), nullable={nullable}))
    
    # Optional: Add index
    {add_index}


def downgrade():
    # Optional: Drop index
    {drop_index}
    
    # Drop column
    op.drop_column('{table_name}', '{column_name}')
""",
    "empty": """
\"\"\"
{message}

Revision ID: {revision}
Revises: {down_revision}
Create Date: {create_date}
\"\"\"

from alembic import op
import sqlalchemy as sa
{imports}

# revision identifiers, used by Alembic
revision = '{revision}'
down_revision = '{down_revision}'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""
}

def create_standard_migration(message):
    """Create a standard Alembic migration using alembic revision command."""
    try:
        # Change to the backend directory where alembic.ini is located
        os.chdir(ROOT_DIR / "backend")
        
        # Run the Alembic revision command
        result = subprocess.run(
            ["alembic", "revision", "--autogenerate", "-m", message],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            logger.info('Migration created successfully.')
            logger.info(result.stdout)
            
            # Extract the created revision file from the output
            for line in result.stdout.splitlines():
                if "Generating" in line and ".py" in line:
                    revision_file = line.split()[-1]
                    logger.info(f"Generated migration file: {revision_file}")
                    return True
        else:
            logger.error('Error creating migration.')
            logger.error(f'Exit code: {result.returncode}')
            logger.error(f'Output: {result.stdout}')
            logger.error(f'Error: {result.stderr}')
            return False
    except Exception as e:
        logger.error(f'Error creating migration: {e}')
        return False

def create_template_migration(template_name, message, **kwargs):
    """Create a migration from a template."""
    try:
        # Change to the backend directory where alembic.ini is located
        os.chdir(ROOT_DIR / "backend")
        
        # First create an empty revision
        result = subprocess.run(
            ["alembic", "revision", "-m", message],
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            logger.error('Error creating empty revision.')
            logger.error(f'Error: {result.stderr}')
            return False
        
        # Extract the created revision file from the output
        revision_file = None
        for line in result.stdout.splitlines():
            if "Generating" in line and ".py" in line:
                revision_file = line.split()[-1]
                logger.info(f"Generated empty migration file: {revision_file}")
                break
        
        if not revision_file:
            logger.error("Couldn't find generated migration file.")
            return False
        
        # Read the generated file to extract revision and down_revision
        with open(revision_file, 'r') as f:
            content = f.read()
        
        # Extract revision and down_revision
        revision = None
        down_revision = None
        create_date = None
        for line in content.splitlines():
            if "revision = " in line:
                revision = line.split("'")[1]
            elif "down_revision = " in line:
                if "None" not in line:
                    down_revision = line.split("'")[1]
                else:
                    down_revision = None
            elif "Create Date:" in line:
                create_date = line.split(":", 1)[1].strip()
        
        # Prepare template parameters
        template_params = {
            'message': message,
            'revision': revision,
            'down_revision': down_revision if down_revision else "None",
            'create_date': create_date,
            'imports': ""
        }
        
        # Add additional parameters from kwargs
        template_params.update(kwargs)
        
        # Special handling for column template
        if template_name == "column":
            if "add_index" not in template_params:
                if template_params.get("create_index", False):
                    template_params["add_index"] = f"op.create_index(op.f('ix_{template_params['table_name']}_{template_params['column_name']}'), '{template_params['table_name']}', ['{template_params['column_name']}'], unique={str(template_params.get('unique', False))})"
                    template_params["drop_index"] = f"op.drop_index(op.f('ix_{template_params['table_name']}_{template_params['column_name']}'), table_name='{template_params['table_name']}')"
                else:
                    template_params["add_index"] = "# No index needed"
                    template_params["drop_index"] = "# No index to drop"
        
        # Get the template content
        template_content = TEMPLATES.get(template_name, TEMPLATES["empty"])
        
        # Fill in the template
        migration_content = template_content.format(**template_params)
        
        # Write the content to the revision file
        with open(revision_file, 'w') as f:
            f.write(migration_content)
        
        logger.info(f"Migration file updated with {template_name} template.")
        return True
    except Exception as e:
        logger.error(f'Error creating template migration: {e}')
        return False

def interactive_mode():
    """Run in interactive mode to gather migration information."""
    logger.info("=== LMS Migration Creator ===")
    
    # Get the migration message
    message = input("Enter migration message/description: ")
    if not message:
        logger.error("Migration message is required.")
        return False
    
    # Ask for migration type
    print("\nSelect migration type:")
    print("1. Standard (Autogenerated)")
    print("2. New Table")
    print("3. Add Column")
    print("4. Empty Migration")
    
    migration_type = input("Enter selection (1-4): ")
    
    if migration_type == "1":
        return create_standard_migration(message)
    elif migration_type == "2":
        table_name = input("Enter table name: ")
        return create_template_migration("table", message, table_name=table_name)
    elif migration_type == "3":
        table_name = input("Enter table name: ")
        column_name = input("Enter column name: ")
        column_type = input("Enter column type (String, Integer, Text, etc.): ")
        nullable = input("Is the column nullable? (y/n): ").lower() == 'y'
        create_index = input("Create an index for this column? (y/n): ").lower() == 'y'
        unique = False
        if create_index:
            unique = input("Should the index be unique? (y/n): ").lower() == 'y'
        
        return create_template_migration(
            "column", 
            message, 
            table_name=table_name, 
            column_name=column_name, 
            column_type=column_type, 
            nullable="True" if nullable else "False",
            create_index=create_index,
            unique=unique
        )
    elif migration_type == "4":
        return create_template_migration("empty", message)
    else:
        logger.error("Invalid selection.")
        return False

def main():
    """Main function for the script."""
    parser = argparse.ArgumentParser(description='LMS Migration Creator')
    
    # Define command-line arguments
    parser.add_argument('--message', '-m', help='Migration message/description')
    parser.add_argument('--template', '-t', choices=['table', 'column', 'empty'], help='Migration template to use')
    parser.add_argument('--table-name', help='Table name for table or column templates')
    parser.add_argument('--column-name', help='Column name for column template')
    parser.add_argument('--column-type', help='Column type for column template')
    parser.add_argument('--nullable', action='store_true', help='Make column nullable (for column template)')
    parser.add_argument('--create-index', action='store_true', help='Create index (for column template)')
    parser.add_argument('--unique', action='store_true', help='Make index unique (for column template)')
    
    args = parser.parse_args()
    
    # Check if Alembic is properly set up
    if not (ALEMBIC_DIR / "env.py").exists():
        logger.error("Alembic doesn't appear to be set up. Please set up Alembic first.")
        return False
    
    # If no message is provided, go into interactive mode
    if not args.message:
        return interactive_mode()
    
    # If a template is specified, use it
    if args.template:
        if args.template == "table" and not args.table_name:
            logger.error("Table name is required for table template.")
            return False
        elif args.template == "column" and (not args.table_name or not args.column_name or not args.column_type):
            logger.error("Table name, column name, and column type are required for column template.")
            return False
        
        if args.template == "table":
            return create_template_migration("table", args.message, table_name=args.table_name)
        elif args.template == "column":
            return create_template_migration(
                "column", 
                args.message, 
                table_name=args.table_name, 
                column_name=args.column_name, 
                column_type=args.column_type, 
                nullable="True" if args.nullable else "False",
                create_index=args.create_index,
                unique=args.unique
            )
        else:  # empty
            return create_template_migration("empty", args.message)
    
    # Otherwise, create a standard migration
    return create_standard_migration(args.message)

if __name__ == "__main__":
    main() 